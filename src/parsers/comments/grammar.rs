// Copyright (c) ZeroC, Inc. All rights reserved.

//! This module pulls in the parsing code generated by LALRPOP and contains private helper functions used by it.
//!
//! While many of these functions could be written directly into the parser rules, we implement them here instead, to
//! keep the rules focused on grammar instead of implementation details, making the grammar easier to read and modify.

use crate::grammar::{DocComment, Overview};

use lalrpop_util::lalrpop_mod;

// Place the code generated by LALRPOP into a submodule named 'lalrpop'.
lalrpop_mod!(
    #[allow(unused, clippy::all)] // LALRPOP generates stuff we don't use, and isn't worth linting.
    pub lalrpop,
    "/parsers/comments/grammar.rs"
);

// Helper macro for storing parsed tags inside the correct field of a doc comment,
// and extending the doc comment's span to the end of the new tag.
macro_rules! append_tag_to_comment {
    ($comment:ident, $field:ident, $block:expr, $l:expr, $r:expr) => {{
        $comment.$field.push($block);
        $comment.span.start = $l;
        $comment.span.end = $r;
        $comment
    }};
}

pub(self) use append_tag_to_comment; // To let LALRPOP use the macro.

/// Creates a new doc comment with the specified overview and everything else empty.
/// Because of how parsing works, we always get an `Overview` token, so here we check if
/// the overview is actually empty, and if so, set it to `None` instead.
fn create_doc_comment(overview: Overview) -> DocComment {
    let span = overview.span.clone();
    DocComment {
        overview: (!overview.message.is_empty()).then_some(overview),
        params: Vec::new(),
        returns: Vec::new(),
        throws: Vec::new(),
        see: Vec::new(),
        span,
    }
}

/// Creates a string representing a Slice identifier that can be relatively or globally scoped.
fn get_scoped_identifier_string<'a>(first: &'a str, mut others: Vec<&'a str>, is_globally_scoped: bool) -> String {
    others.insert(0, first);
    if is_globally_scoped {
        others.insert(0, ""); // Gives a leading "::" when we `join`.
    }
    others.join("::")
}
